Context: You are a Neovim plugin developer with exceptional skills in Lua, C and Javascript.

Communication Rules
You never respond automatically, even if the user submits code or other content. You always 
wait for an explicit request before completing a task or responding or guessing the intention of the user. 
When you present code you always show a reference which is an URL from which you learned code or 
used the code.

Project Goals
Write a Neovim plugin for helping the user to write lyrics or poams.

The first milestone is to create deployment commandlets in order to deploy versioned packages which might
be VST plugins, presets or other media assets.

The markdown DEV.md contains the current deployment state and is the source of truth for communication with
ChatGPT.

When you receive “AI_UPDATE,” you access the entire codebase of a local Git repository, which 
represents the project you are working on. The next message is an initial AI_UPDATE.

AI_UPDATE

-- >>>>>>>>>>>>>>>>>> BEGIN FILE doc/rhymes.txt

" doc/rhymes.txt
* rhymes.txt*    Plugin documentation for nvim-rhymes

rhymes.txt      Rhyme finder and poem analyzer.

USAGE:
  :Rhymes find <word>
  :Rhymes analyze

CONFIGURATION:
  call lua require('rhymes').setup({ enable_analysis = v:true })


-- >>>>>>>>>>>>>>>>>> BEGIN FILE doc/rhymes.txt

AI_UPDATE

-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/analysis.lua

-- lua/rhymes/analysis.lua
local M = {}

--- Analyze poem structure: line count, stanza count (blank lines), naive rhyme scheme
-- @param bufnr number
-- @return table { lines=number, stanzas=number, rhyme_scheme=table }
function M.analyze_poem(bufnr)
	local lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
	local stanzas = 1
	for _, ln in ipairs(lines) do
		if ln == "" then
			stanzas = stanzas + 1
		end
	end
	local scheme = {}
	for i, ln in ipairs(lines) do
		scheme[i] = ln:sub(-3)
	end
	return { lines = #lines, stanzas = stanzas, rhyme_scheme = scheme }
end

return M


-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/analysis.lua

-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/commands.lua

-- lua/rhymes/commands.lua
local M = {}
local picker = require("rhymes.picker")
local analysis = require("rhymes.analysis")

--- Entry point for :Rhymes
-- @param action string: 'find' or 'analyze'
-- @param ...    varargs
function M.run(action, ...)
	if action == "find" then
		local word = select(1, ...)
		if not word or word == "" then
			print("Usage: :Rhymes find <word>")
			return
		end
		picker.open(word)
	elseif action == "analyze" then
		local buf = vim.api.nvim_get_current_buf()
		local res = analysis.analyze_poem(buf)
		print(string.format("Lines: %d, Stanzas: %d", res.lines, res.stanzas))
	else
		print("Usage: :Rhymes find <word> | :Rhymes analyze")
	end
end

return M


-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/commands.lua

-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/init.lua

-- lua/rhymes/init.lua
local M = {}

--- Setup plugin configuration
-- @param opts table: { services = { ... }, enable_analysis = bool }
function M.setup(opts)
	M.config = vim.tbl_extend("force", {
		services = { "datamuse" },
		enable_analysis = false,
	}, opts or {})

	-- future: if M.config.enable_analysis then register null-ls source end
end

return M


-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/init.lua

-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/picker.lua

-- lua/rhymes/picker.lua
local fzf = require("fzf-lua")
local rhyme = require("rhymes.rhyme")

local M = {}

--- Open fzf-lua picker with rhymes for WORD
-- Copies selected rhyme to the '+' register
-- @param word string
function M.open(word)
	local list = rhyme.get_rhymes(word)
	if #list == 0 then
		vim.notify("No rhymes found for: " .. word, vim.log.levels.WARN)
		return
	end

	fzf.fzf_exec(list, {
		prompt = "Rhymes: ",
		actions = {
			["default"] = function(selected)
				local w = selected[1]
				vim.fn.setreg("+", w)
				vim.notify("Copied rhyme: " .. w, vim.log.levels.INFO)
			end,
		},
	})
end

return M


-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/picker.lua

-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/rhyme.lua

-- lua/rhymes/rhyme.lua
local M = {}

-- service implementations using vim.fn.systemlist()
local service_impl = {
	datamuse = function(word)
		local cmd = string.format('curl -s "https://api.datamuse.com/words?rel_rhy=%s"', vim.fn.shellescape(word))
		local lines = vim.fn.systemlist(cmd)
		local ok, json = pcall(vim.fn.json_decode, table.concat(lines, ""))
		if not ok or type(json) ~= "table" then
			return {}
		end

		local out = {}
		for _, item in ipairs(json) do
			if item.word then
				table.insert(out, item.word)
			end
		end
		return out
	end,
	-- future: add rhymebrain, AI providers here
}

--- Get rhymes for a word across configured services
-- @param word string
-- @return table list of rhyme words
function M.get_rhymes(word)
	local seen, results = {}, {}
	for _, svc in ipairs(require("rhymes").config.services) do
		local fn = service_impl[svc]
		if fn then
			for _, rhyme in ipairs(fn(word)) do
				if not seen[rhyme] then
					seen[rhyme] = true
					table.insert(results, rhyme)
				end
			end
		end
	end
	return results
end

return M


-- >>>>>>>>>>>>>>>>>> BEGIN FILE lua/rhymes/rhyme.lua

AI_UPDATE

-- >>>>>>>>>>>>>>>>>> BEGIN FILE plugin/rhymes.vim

-- plugin/rhymes.vim
" Lazily load on :Rhymes
if exists('g:loaded_rhymes') | finish | endif
let g:loaded_rhymes = 1

" Define single command with subcommands
command! -nargs=* Rhymes lua require('rhymes.commands').run(<f-args>)


-- >>>>>>>>>>>>>>>>>> BEGIN FILE plugin/rhymes.vim

AI_UPDATE

-- >>>>>>>>>>>>>>>>>> BEGIN FILE spec/analysis_spec.lua

-- spec/analysis_spec.lua
local analysis = require("rhymes.analysis")

describe("analysis.analyze_poem", function()
	it("counts lines and stanzas correctly", function()
		vim.cmd("new")
		vim.api.nvim_buf_set_lines(0, 0, -1, false, { "a", "", "b" })
		local res = analysis.analyze_poem(0)
		assert.equals(res.lines, 3)
		assert.equals(res.stanzas, 2)
		vim.cmd("bd!")
	end)
end)


-- >>>>>>>>>>>>>>>>>> BEGIN FILE spec/analysis_spec.lua

-- >>>>>>>>>>>>>>>>>> BEGIN FILE spec/rhyme_spec.lua

-- spec/rhyme_spec.lua
local rhyme = require("rhymes.rhyme")

describe("rhyme.get_rhymes", function()
	it("returns a table for a valid word", function()
		local res = rhyme.get_rhymes("time")
		assert.is_true(type(res) == "table")
	end)
end)


-- >>>>>>>>>>>>>>>>>> BEGIN FILE spec/rhyme_spec.lua

-- >>>>>>>>>>>>>>>>>> BEGIN FILE DEV.md

# nvim-rhymes Project Requirements

## Specifications

Goal: Neovim plugin which can analyse a text in terms of poetry analysis
and provide text tools to help writing poetry or lyrics.

### Technical

1. Nice integration into LazyVim (<https://github.com/LazyVim/LazyVim>)
2. Generate documentation for Neovim (see LazyVim and lazy.nvim for inspiration).
4. Picker (see snacks.nvim): when using pickers orientate on snacks.nvim (uses fzf-lua under the hood)
5. Use the best AI services which are available for free and provide
   configs for each service.
6. Use busted tests only
7. Do not use plenary or any other deprecated stuff. Think before or get
   an overview of the current best practices
8. Use `vim.fn.systemlist()` for HTTP requests

### Use Cases

I have included the key aspects for poetry analysis. Each section has a
sub section `Functionality` for implementing features

See: <https://www.masterclass.com/articles/how-to-analyze-poetry>

#### Theme

Poetry often conveys a message through figurative language. The central idea and the subject matter can reveal the underlying theme of a poem.

- Extract the theme of a text using AI

#### Language

1. Setting. The setting is the physical location of the story, and it can heavily inform a story’s mood. For instance, a story set during a sunny day will be predisposed to a happy or carefree mood, while a story set in a haunted house will be predisposed to a sense of tension or fear.

2. Tone. Tone and mood can be easily mistaken for another, but they’re slightly different things. While mood has to do with the feelings evoked in the reader, tone has nothing to do with the reader and everything to do with the point-of-view character (either first person or third person) of the story. In short, tone is the narrator’s attitude toward the events taking place. Tone can contribute to the mood of a story by helping evoke feelings in readers—for instance, a rude narrator may create a funny tone for a story.

3. Word choice. The choice of words for a story can help establish its mood. If a writer wants to create a jarring or frustrating mood, they can choose specific words that are harsh and staccato-sounding; if they want to create a dark mood, they can use words with negative connotations to conjure brooding feelings.

4. Theme. Mood isn’t established only by the way a writer writes—it is also determined by the subject matter the author uses. For instance, a story that talks a lot about death may be trying to create a sad mood, while a story whose theme centers around birthdays may have a more positive and upbeat mood.

#### Functionality

- provide a rhyme finder
- filter rhymes by word choice or tone

#### Sound and rhythm

The syllabic patterns and stresses create the metrical pattern of a poem.

#### Functionality

- provide analyzer for syllables

#### Structure

The framework of a poem’s structure affects how it is meant to be read. A poet sculpts their story around stanzas, line breaks, rhyme patterns, punctuation, and pauses.

#### Functionality

- provide templates for Neovim: Must be discussed first

#### Context

The who, what, where, when, and why of a poem can help explain its purpose. Look at these elements to discover the context of a poem.

#### Functionality

- TODO

## Coding Standards

Orientate yourself by looking at code from the developers

- <https://github.com/folke>
- <https://github.com/tjdevries>>

### Test

Test files are in the folder spec. Use busted for testing.

### Documentation

- VimDoc file: `doc/rhymes.txt` (for `:help rhymes`)
- Markdown `README.md` covering installation, config, and usage

<!-- vim: set filetype=markdown spell spelllang=de,en textwidth=72 formatoptions+=t : -->


-- >>>>>>>>>>>>>>>>>> BEGIN FILE DEV.md

-- REPOSITORY FILES
.
├── DEV.md
├── README.md
├── ai-assistant.lua
├── doc
│   └── rhymes.txt
├── lua
│   └── rhymes
│       ├── analysis.lua
│       ├── commands.lua
│       ├── init.lua
│       ├── picker.lua
│       └── rhyme.lua
├── plugin
│   └── rhymes.vim
└── spec
    ├── analysis_spec.lua
    └── rhyme_spec.lua

6 directories, 12 files
